gradient_x= np.zeros((rows-2, cols-2), dtype=float)
gradient_y=np.zeros((rows-2, cols-2), dtype=float)
mag = np.zeros((rows-2, cols-2), dtype=float)
direct = np.zeros((rows-2, cols-2), dtype=float)
for i in range(1, rows - 1):
        for j in range(1, cols - 1):
            neighborhood = gray_image[i-1:i+1, j-1:j+1]
            gradient_x[i-1][j-1]=( np.sum(neighborhood * gx))
            gradient_y[i-1][j-1]=(np.sum(neighborhood * gy))
            mag[i-1][j-1]=(math.sqrt(gradient_x[i-1][j-1]**2 + gradient_y[i-1][j-1]**2))
            direct[i-1][j-1]=math.atan(gradient_y[i-1][j-1]/gradient_x[i-1][j-1])

import numpy as np

def non_max_suppression(mag, direct):
    rows, cols = mag.shape
    suppressed = np.zeros((rows, cols), dtype=np.float32)

    # Convert angles from radians to degrees [0,180)
    angle = np.rad2deg(direct) % 180

    for i in range(1, rows - 1):
        for j in range(1, cols - 1):
            q = 255
            r = 255

            # Check gradient direction
            if (0 <= angle[i, j] < 22.5) or (157.5 <= angle[i, j] <= 180):
                q = mag[i, j + 1]
                r = mag[i, j - 1]
            elif 22.5 <= angle[i, j] < 67.5:
                q = mag[i + 1, j - 1]
                r = mag[i - 1, j + 1]
            elif 67.5 <= angle[i, j] < 112.5:
                q = mag[i + 1, j]
                r = mag[i - 1, j]
            elif 112.5 <= angle[i, j] < 157.5:
                q = mag[i - 1, j - 1]
                r = mag[i + 1, j + 1]

            # Keep only if greater than neighbors
            if (mag[i, j] >= q) and (mag[i, j] >= r):
                suppressed[i, j] = mag[i, j]
            else:
                suppressed[i, j] = 0

    return suppressed
nms_result = non_max_suppression(mag, direct)
